---
published: true
---
## Insertion Sorting
বিভিন্ন প্রকার সর্টিং এর মধ্যে এক ইনসার্শন সর্টিং এক প্রকারের সর্টিং। ইনসার্শন সর্টিং এ যা করা হয় তা হল বড় ছোট তুলনা করে প্রত্যেকটি ডাটার উপযুক্ত জায়গায় ইনসার্ট করা হয়। 
মনে করেন, আপনার ক্লাসে এলোমেলোভাবে ছাত্ররা বসে আছে। ফ্যাকাল্টি সবাইকে রোল নং এর ক্রমানুসারে বসাতে চাইল। উনি একটি পদ্ধতি অনুসরণ করে কাজটি করতে চাইলেন। পদ্ধতিটা এরকম:-
 বুঝানোর সুবিধার্থে একটি কলামের ছাত্রদের বিবেচনা করা যাক। কলামের ছাত্রসংখ্যা ১০ জন। প্রথমে যে বসা তার সাথে ঠিক পরের জনের সাথে তুলনা করা হল। পরের জনের রোল নং যদি ছোট হয় তাহলে তাকে সামনে বসানো হবে আর পরের জন যাবে সামনের কলামে। এর পরের বার ৩য় জনের সাথে ২য় জনের তুলনা করা হবে, যদি ৩য় জনের রোল নং ২য় জনের চেয়ে ছোট হয় তাহলে ৩য় জন চলে যাবে ২য় জনের জায়গায়। তারপর আবার ৩য় জনের রোল নং এর সাথে ১ম জনের রোল নং এর তুলনা করা হবে। যদি ৩য় জনের রোল নং এর মান ছোট হয় তবে ৩য় জন একেবারে সামনে চলে যাবে। 
আর ২য় জনের রোল নং এর মান যদি বড় হয় তবে কোনো পরিবর্তন হবে না।
এরপর আবার ৪র্থ জনের রোল নং এর সাথে ঠিক একইভাবে তুলনা করা হবে। এ প্রক্রিয়াটি শেষ বেঞ্চের ছাত্র পর্যন্ত চলবে। 
এইভাবে আপনার ফ্যাকাল্টি ছাত্রদেরকে একটি কলামে রোল নং অনুসারে বসাতে পারবেন।
প্রক্রিয়াটা ইনসার্শন সর্ট এর মত-ই।
ইনসার্শন সর্ট উদাহরণ দিয়ে বুঝানো যাক:-
arr[10] ={4,5,2,7,30,9,8,12,6,56};
arr[10]- এ ১০ টি ডাটা রয়েছে যেগুলো আনসর্টেড। ইনসার্শন সর্টিং করতে হলে কোডটি হবে এরকম:-
<pre>
#include <iostream> 
using namespace std; 
int main() 
{ 
    int arr[10] ={4,5,2,7,30,9,8,12,6,56}; 
    for (int j=0; j<10; j++) 
    { 
        int value=arr[j]; 
        int temp; 
        int k=j-1; 
        while (arr[k]>value &&k>=0) 
        { 
            int temp=arr[k+1]; 
            arr[k+1]=arr[k]; 
            arr[k]=temp; 
             k--; 
        } 
    } 
    for (int j=0; j<10; j++) <br>
    { 
        cout<<arr[j]<<" "; <br>
    } 
    return 0; 
} 
</pre>
for (int j=1; j<10; j++) <br>
এই লাইন দিয়ে একটি লুপ ইটারেট করা হয়েছে যেটি 1 থেকে আরম্ভ হবে এবং সাইজের আগ পর্যন্ত চলবে। 
while (arr[k]>value&&k>=0) <br>
while লুপটি এক্সিকিউট হবে যদি k এর ভ্যালু 0  থেকে বড় এবং arr[k] যদি value থেকে বড় হয়। এখানে arr[k] হল j এর পেছনের ইনডেক্স এর অ্যারের মান। আর value হল প্রত্যেকবার for লুপ এক্সিকিউট হবার পর arr[j] এর ভ্যালু। 
এখানে যা হচ্ছে সেটা হল ফর লুপ দিয়ে প্রথমে অ্যারে এর দ্বিতীয় ইনডেক্স থেকে লুপিং করে while লুপের মাধ্যমে ঠিক আগের ইনডেক্স এর অ্যারের সাথে তুলনা করে বড় হলে শিফটিং করে দেয়া হচ্ছে। 
পরের বার এই কাজটি ৩ নং ইনডেক্স এর অ্যারের  সাথে এর আগের ইনডেক্স এর অ্যারের উপাদানের তুলনা করা হচ্ছে। এভাবে ঠিক শেষ ইনডেক্স পর্যন্ত এই প্রক্রিয়াটি চলার পর একটি সর্টেড অ্যারে পাওয়া যায়।
আশা করি বুঝতে পেরেছেন। <br>
ধন্যবাদ



<h1>Recursion </h1>

নায়ক সাকিব খান প্রোগ্রামিং কন্টেস্ট করে হেটে হেটে বাসায় ফিরছিল।পথিমধ্যে সে দেখিতে পাইল, বলিউড কিং নায়ক শাহরুখ খান বটতলায় বসিয়া নিজের নাম ধরে নিজেই ডাকাডাকি করতেছে। শাহরুখ খানের পাশে বসা তাহার সেক্রেটারি সাকিব খানকে বলিল, "শাহরুখ খান বড় আশা করিয়া মুম্বাই থেকে ঢাকা শহরে আসিয়াছিলেন পুরান ঢাকার নান্নার বিরিয়ানী খাওয়ার জন্য,  ঢাকায় আসার পর গুলিস্তানে এক ছিনতাইকারী তাহার সর্বস্ব লুটপাট করিয়া নিয়াছে। তাই তাহার কাছে বিরিয়ানী খাওয়ার টাকা নেই। আর এজন্যই বিরিয়ানী না খেতে পারার শোকে পাগল হইয়া নিজের নাম ধরিয়া নিজেই ডাকিতে লাগিল।" সেক্রেটারী আরও  বলিল যে, বিরিয়ানী না খাওয়া পর্যন্ত মনে হয় তাহার এই পাগলামি বন্ধ হইবে না। পরে সাকিব খান শাহরুখ খানকে বলিল, "মে হু না! আমি তোমাকে বিরিয়ানী খাওয়াব।" শাহরুখ খান তো অনেক খুশি। সে আর নিজের নাম ধরে নিজে ডাকে নি।
এবার আসল কথায় আসা যাক। এখানে শাহরুখ খানকে মনে করুন একটা ফাংশন যে নিজেকে নিজেই ডাকে। রিকার্শন এর কনসেপ্ট টা ঠিক একই রকম। কোনো ফাংশন যদি নিজেই নিজেকে কল করে তাহলে সেটা রিকার্শন।
আচ্ছা, শাহরুখ খান নামের একটা ফাংশন লিখা যাক যা শাহরুখ খান প্রিন্ট করবে।
<pre>
 #include <iostream>
using namespace std;
void printShahrukhKhan()
{
    cout<<"Shahrukh Khan"<<endl;
    printShahrukhKhan();
}
int main()
{
    printShahrukhKhan();
    return 0;
}
</pre>
এ প্রোগ্রামটি তে যা হয়েছে তা হল int main() ফাংশন থেকে printShahrukhKhan() ফাংশনটি কল হয়েছে। পরে printShahrukhKhan() ফাংশনে Shahrukh Khan লিখাটি প্রিন্ট করেছে। তারপর এই ফাংশনটি আবার কল হয়েছে। আবার একইভাবে ফাংশনটি বারবার কল হতে থাকবে।
ফলে এখানে অনবরত Shahrukh Khan প্রিন্ট হতেই থাকবে। এজন্য দরকার বেজ কেইস। বেজ কেস হল কোনো একটি কন্ডিশন যা ফাংশনের রিকার্সিভ কলকে থামাবে। 
উপরের ঘটনায় শাহরুখ খান যখন শুনেছিল সাকিব খান তাকে বিরিয়ানী খাওয়াবে তখন শাহরুখ খান পাগলের মত নিজেকে নিজে ডাকে নি। 
এর সাথে মিল রেখে প্রোগ্রাম লিখা যাক:-
<pre>
#include <iostream>
using namespace std;
void printShahrukhKhan(bool opinion)
{
     if (opinion==true)
         {
              cout<<"Yaaaahooo! ami biriyani      khabo!";
return;
         {
    cout<<"Shahrukh Khan"<<endl;
    printShahrukhKhan(opinion);
}
int main()
{
    bool ShakibKhanBiriyaniKhaoabe=true;   printShahrukhKhan(ShakibKhanBiriyaniKh aoabe);
    return 0;
}
</pre>
এখানে, if (opinion==true)..........return; এই অংশটুকু হল বেজ কেইস। তার মানে  যদি সাকিব খান শাহরুখ খানকে বিরিয়ানী খাওয়ায় তাহলে সে আর নিজের নাম ধরে ডাকবে না। আর যদি না খাওয়ায় তাহলে opinion==false হবে ফলে ফাংশনটি রিটার্ণ হবে না যার ফলে সেটা অনবরত কল হতে থাকবে।
